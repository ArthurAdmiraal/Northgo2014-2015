#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Hubs,  S4, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorI2CCustom)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_Matrix_S1_1, motor1,        tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, motor2,        tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, motor3,        tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S1_4, motor4,        tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S4_1, motor5,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S4_2, motor6,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S4_3, motor7,        tmotorMatrix, openLoop, reversed)
#pragma config(Motor,  mtr_Matrix_S4_4, motor8,        tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S4_1, servo5,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S4_2, servo6,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S4_3, servo7,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S4_4, servo8,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///////////////////////////////////////////////////////////////////////////
// Autonomous.c                                                          //
// Autonomous program for Robot C using the OmniWheelDriver_gyro library //
// Used by team OmegaVoltz at FTC Dutch Open 2015                        //
// Copyright (C) 2014  Arthur Admiraal                                   //
//                                                                       //
// This program is free software: you can redistribute it and/or modify  //
// it under the terms of the GNU General Public License as published by  //
// the Free Software Foundation, either version 3 of the License, or     //
// (at your option) any later version.                                   //
//                                                                       //
// This program is distributed in the hope that it will be useful,       //
// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
// GNU General Public License for more details.                          //
//                                                                       //
// You should have received a copy of the GNU General Public License     //
// along with this program.  If not, see <http://www.gnu.org/licenses/>. //
///////////////////////////////////////////////////////////////////////////

// include drivers
#include "JoystickDriver.c"        // Include file to handle the Bluetooth messages
#include "OmniWheelDriver_gyro.h"  // Include driver for the omniwheels
#include "hitechnic-compass.h"     // Include compass sensor file
#include "hitechnic-irseeker-v2.h" // Include driver for the IR Seeker V2
#include "lego-light.h"            // Include driver for the light sensors
#include "lego-touch.h"            // Include driver for the touch sensors
#include "lego-ultrasound.h"       // Include driver for the ultrasound sensors

// define some constants
#define LIMIT 		 	 10		//
#define TUBE_DIST 	100		// distance from platform the robot has to drive in order to grab a tube
#define MIDDLE_DIST  70		// distance from platform to the middle of the field
#define SPEED 		 	 40		// the max speed of the robot during the autonomous phase

// the IR sensor variables and defines, for finding the tower orientation
#define DISTLIMIT  10
#define TURNLIMIT 180
#define TURNSTART  0

#define POS30CM		27
#define POS60CM		47
#define POSLIMIT	40

#define lTch			msensor_S2_3
#define liftServ  servo2
#define snrSens   msensor_S2_1
#define snrSens2  msensor_S2_2
int rMtr = motor8;
int lMtr = motor7;

int IRValue[TURNLIMIT];
int IRValue2[TURNLIMIT];

tHTIRS2 irSeeker;

void initIR();
void doScan(int *arrayPtr);
int  calcConfiguration();
int  IRFindBlobs(int *arrayPtr);
int  findRising(int *arrayPtr, int in);
int  findFalling(int *arrayPtr, int in);

// define some variables
int head    = 0;
int state   = 1;

int configuration = -1;

bool firstTime = true;

void distToWall(int wallDist);
void goFwd(int sp, int t);
void scoreBall();
void goLift(int height);
void liftDown();
void waitUpdate(int t);
void waitDone();
void scoreSmallBall();
void goFwd2(int sp, int t);

task main()
{
	servo[servo2] = 0;
	servo[servo3] = 180;

	OWinitialize(S3, 45, 135, 225, 315);	// initialize the omniwheel driver with the compass sensor on sensor port 2

	waitForStart();

	head = heading+180;
	OWsetCalibration(head);

	waitUpdate(500);

	goFwd(40, 3000);
	distToWall(16);
	goFwd(40, 1500);
	waitDone();
	distToWall(16);

	goLift(POS60CM);

	goFwd(40, 1900);

	scoreSmallBall() //possibly include code to score small ball

	goFwd(-40, 1000);

	goLift(POS30CM);

	waitUpdate(1000);
	distToWall(72);
	waitUpdate(1500);

	OWsetTurnTargetRelative(-45);
	waitUpdate(2000);
	goFwd2(40, 1800);

	OWsetTurnTargetRelative(45);
  waitUpdate(1000);
	goFwd(30, 2000);

	scoreBall();

	goFwd(-40, 1000);

	liftDown();

	OWsetTurnTargetRelative(180);
	waitDone();

	while(true) {OWupdate();}

	/*goFwd(20, 2000);

	waitUpdate(500);
	servo[servo3] = 180;
	servo[servo3] =  35;
	waitUpdate(500);

	goFwd(-40, 4000);

	while(true) {OWupdate();}*/
}

void distToWall(int wallDist) {
	nMotorPIDSpeedCtrl[motor1] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor2] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor3] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor4] = mtrSpeedReg;
	int dist2 = USreadDist(snrSens2);
	int prevDist = dist2;
	while((dist2!=wallDist)||((dist2-prevDist)!=0)) {
		prevDist = dist2;
		dist2 = USreadDist(snrSens2);
		OWsetDriveVec(4*constraini(dist2-wallDist, -5, 5), 0);
		OWupdate();
	}
	nMotorPIDSpeedCtrl[motor1] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor2] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor3] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor4] = mtrNoReg;

	motor[motor1] = 0;
	motor[motor2] = 0;
	motor[motor3] = 0;
	motor[motor4] = 0;
}

void goFwd(int sp, int t) {
	nMotorPIDSpeedCtrl[motor1] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor2] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor3] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor4] = mtrSpeedReg;

	clearTimer(T1); // global program timer
	while(time1[timer1] < t) {
		OWsetDriveVec(0, sp/*constraini(6*(30-USreadDist(snrSens2)), -30, 30)*/);
		OWupdate();
	}
	OWsetDriveVec(0, 0);
	OWupdate();

	nMotorPIDSpeedCtrl[motor1] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor2] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor3] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor4] = mtrNoReg;

	motor[motor1] = 0;
	motor[motor2] = 0;
	motor[motor3] = 0;
	motor[motor4] = 0;
}

void goFwd2(int sp, int t) {
	nMotorPIDSpeedCtrl[motor1] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor2] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor3] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motor4] = mtrSpeedReg;

	clearTimer(T1); // global program timer
	while(time1[timer1] < t) {
		OWsetDriveVec(sp, 0/*constraini(6*(30-USreadDist(snrSens2)), -30, 30)*/);
		OWupdate();
	}
	OWsetDriveVec(0, 0);
	OWupdate();

	nMotorPIDSpeedCtrl[motor1] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor2] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor3] = mtrNoReg;
	nMotorPIDSpeedCtrl[motor4] = mtrNoReg;

	motor[motor1] = 0;
	motor[motor2] = 0;
	motor[motor3] = 0;
	motor[motor4] = 0;
}

void scoreBall() {
	motor[motorB] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	motor[motorB] = -100;
	motor[motorC] = -100;
	while(nMotorEncoder[motorB]>-400){}
	motor[motorB] = 100;
	motor[motorC] = 100;
	while(nMotorEncoder[motorB]<200){}
	motor[motorB] = 0;
	motor[motorC] = 0;
}

void scoreSmallBall() {
	motor[motorB] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	motor[motorB] = -100;
	motor[motorC] = -100;
	servo[servo2] = 255;
	while(nMotorEncoder[motorB]>-80){}
	motor[motorB] = 100;
	motor[motorC] = 100;
	while(nMotorEncoder[motorB]<200){}
	motor[motorB] = 0;
	motor[motorC] = 0;
}


void goLift(int height) {
	int dist = 0;
	while(dist!= height) {
		dist = USreadDist(snrSens);
		if((dist < height)||(dist==255)) {
			motor[rMtr] =  100 - 2*pow(constraini(5-abs(dist-height), 0, 5)*(!TSreadState(lTch)), 2);
			motor[lMtr] =  100 - 2*pow(constraini(5-abs(dist-height), 0, 5)*(!TSreadState(lTch)), 2);
		} else {
			motor[rMtr] = -100 + 20*constraini(5-(dist-height), 0, 5)*(!TSreadState(lTch));
			motor[lMtr] = -100 + 20*constraini(5-(dist-height), 0, 5)*(!TSreadState(lTch));
		}
	}

	motor[rMtr] =  0;
	motor[lMtr] =  0;
}

void liftDown() {
	while(!TSreadState(lTch)) {
		motor[rMtr] = -100*(!TSreadState(lTch));
		motor[lMtr] = -100*(!TSreadState(lTch));
	}

	motor[rMtr] = 0;
	motor[lMtr] = 0;
}

void waitUpdate(int t) {
	clearTimer(T1);
	while(time1[timer1] < t){OWupdate();}
}

void waitDone() {
	while(!OWisDone()){OWupdate();}
}
